# ЛР. Лекция 2

## Простейшая (!!!) схема работы аппаратных прерываний

Концептуальная трехшинная схема, на основе которой построены наши компы

В третьем поколении ЭВМ была реализована возможность распараллеливания функций (с помощью канала).
Это привело к появлению в системах 3 поколения полноценной системы прерываний, которая имеется во всех совр. операционных системах.

Совр. ЭВМ имеют шинную архитекутру (мэнфреймы имели канальную архитектуру)

В шинной архитектуре с внеш. устройствами работают контроллеры. Контроллеры входят в состав внеш. устр. Адаптеры - на материнской плате.

Контроллер - это программно управляемое устройство, которое получает команду от процессора и работает с внешними устройствами (???)

Сигналы трех типов:

	1. Данные: команды и данные

	2. Адреса
	
	3. Сигналы управления

В компьютере каждый тип сигнала передается по отдельной шине (3 шины: данных, адреса и управления)

[картинка 1]

Устройства ЭВМ взаимодействуют др с др с помощью этих шин и соответствующих сигналов.

Данные, кот мб команды и данные, передаются по шине данных, так как с точки зрения системы это одно и то же.

!!! Техническое воплощение сложнее (что-то про невозможность параллельных передач при высоких частотах, но это не факт, надо проверить)

Внешние устройства также обмениваются с процессором теми же сигналами (УВВ - устройства ввода/вывода)

Возникла необходимость о реализации механизма уведомления процессору о завершении ввода/вывода из-за контроллеров.
УВВ подает сигнал прерывания, который приходит на контроллер прерывания. В 16-разрядных системах был PIC. Входы - IRQ0, IRQ1 и тд (Interrupt Request).
IRQ0 - прерывание системного таймера (тик). IRQ1 - прерывание от клавиатуры PS/2. На IRQ12 - прерывания от мыши PS/2. В старых сис. блоках это были круглые разьемы
зеленого и фиолетого цветов.

[что-то про INT]

В конце цикла выполнения каждой команды, процессор проверяет на своей выделенной ножке сигнал прерывания. Если сигнал пришел, процессор присылает ответный сигнал INTA (Interrupt Answer).
Получив этот сигнал, контроллер выставляет на ШД вектор прерывания. Процессор получает этот вектор и в DOS этот вектор используется как смещение к вектору прерывания в ТВП (таблица векторов прерываний).

Получив этот вектор, процессор переходит по адресу обработчика прерыв. и выполняет его. При этом выполнение программы прерывается,
и, чтобы восстановить выполнение программы, необходимо запомнить содердимое регистров процессора, чтобы затем их восстановить (сохранение аппаратного контекста).

push ax, dx, ds, es (?????????)

При переходе на 32-разр. сист. PIC -> IPIC (расш. контроллер прерыв.). В совр. системах - MSI.
В распоряжение программиста предоставляются команды ассемблера этим умным железам (т.е. как интерфейс).
Сделано это для совместимости.

## Формирования вектора прерывания

вектор прерывания = базовый вектор + NIRQ

В реальном режиме ведущий вектор равен 8 (поэтому int 8h)

Для клавы - 9 [нужно объяснение]

2^20 = 1 Mb = 1024 Kb = fffff (не забываем, что шина адреса 20 разрядная, невозможно за один такт получить 20 разрядный адрес из 16 разрядного)

В начале обработчика прерывания - 4 пуша - сохранения содержимого регистров процессора,
потому что прерывание от системного таймер имеет наивысший приорите и прерывает любую выполняемую работу.
В 64-разр. ОС управляется разделением времени: процессорное время квантуется, и из-за огромной частоты работы системы [что-то про декремент кванта].
Почему мы видим 4 пуша? Потому что DOS - однозадачная система. На самом деле 2 программы: ОС и программа. Выглядит это следующим образом:

[картинка 2]

Существуют карты первого мегабайта (расписаны все части адресов, использующиеся ОС [???])

В памяти в DOS находятся две программы: [...]

Резидентная - постоянно в памяти
Транзитная - загружается, когда необходимо

[paging и non-paging]
[о том, что остается куча после загрузки программы в память]

Обработчки прерывания явл. частью кода ОС.

DOS минимизировался, поэтому сохраняются только те регистры, которые изменяются в коде.
Есть pusha и popa для ВСЕХ регистров

## Почему появилась потребность в теореме Бема-Якопини?

Для поиски ошибки в программе на Fortran 4 в листинге
приходилось рисовать связи (вот вам и спагетти код). Эта теорема позволила упростить написание и чтение кода [???]
В результате появилось структурное программирование (программирование без goto).

! В основе программирования лежит алгоритмизация.

## Как правильно рисовать вложенные if (нет в методичке)

В обработчике прерваний [и где-то еще] нет циклов, но есть вложенные if

[картинка 3]

"Нет - для лохов" (c) Рязанова Н.Ю.

По ГОСТу элементы алгоритма должны быть примерно одного размера.

!!! Алгоритмы строятся, чтобы проработать все ифы, циклы и пр.

Неверно:

[картинка 4]

## Вложенные циклы

[картинка 5]

В ЛР1 не все флаги IF!!!!!!!!!!
