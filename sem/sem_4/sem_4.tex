\documentclass[a4paper, 14pt]{report}

\usepackage{extsizes}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}%включаем свою кодировку: koi8-r или utf8 в UNIX, cp1251 в Windows
\usepackage[english,russian]{babel}%используем русский и английский языки с переносами
\usepackage{amssymb,amsfonts,amsmath,mathtext,cite,enumerate,float} %подключаем нужные пакеты расширений
\usepackage{graphicx} %хотим вставлять в диплом рисунки?

\makeatletter
\renewcommand{\@biblabel}[1]{#1.} % Заменяем библиографию с квадратных скобок на точку:
\makeatother

\usepackage{titlesec}

\usepackage{geometry} % Меняем поля страницы
\geometry{left=3cm}% левое поле
\geometry{right=1cm}% правое поле
\geometry{top=2cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле

\renewcommand{\theenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumi}{\arabic{enumi}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{.\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{.\arabic{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}% Меняем везде перечисления на цифра.цифра

\usepackage{indentfirst}

\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter.}{1ex}{\Huge\bfseries}

\graphicspath{{images/}}%путь к рисункам

\begin{document}
	\section*{Сигналы}
	
	В UNIX сигналы являются базовым инструментом информирования процессов о событиях в системах. Важнейшим событием в системе является завершение процесса. Процесс может завеошаться по разным причинам: нормальное завершение, завершение в результате команды kill, завершение в результате действий с клавиатуры.
	
	Процесс может определить собственную реакцию на получаемый сигнал. Процесс может игнорировать получаемый сигнал, реагировать на сигнал по умолчанию (так, как определено в системе) или определить собственную реакцию. Для этого необходимо, чтобы был написан собственный обработчик сигнала (классич. название - handler).
	
	Мы используем системный вызов signal. С его помощью выполняется {\bf регистрация} нашего обработчика на указанном сигнале.
	
	!!! signal не входит в POSIX 1. Поэтому не рекомендуется использовать его при написании переносимого ПО. Есть системный вызов, который входит в POSIX - sigaction [почитать о нем].
	
	Для чего процессу нужно определять собственную реакцию на полученный сигнал? С помощью техники сигналов можно менять ход выполнения программы.
	
	!!! И signal, и sigaction есть в ANSI C.
	
	\section*{Процессы-демоны}
	
	{\it 13-я глава из великой классики}
	
	Демон управляет диспетчеризацией. Системы поддерживают потоки уровня ядра, поэтому в Linux видим k thread daemon. Демоны предназначены для решения важных системных задач.
	
	Процессы очень дорогие, поэтому проблема многопоточности серьзная, поскольку если запускаются потоки, то резко увеличивается размер кучи. Важнейший ресурс системы - память.
	
	\section*{Правила программирования демонов}
	
	Все эти правила реализованы функцией demonize (вызывается в main, main - это предок)
	
	\begin{enumerate}
		\item Сброс маски режима создания файлов: umask(0);
		
		umask вызывается в предке сразу в начале функции demonize. Но потомок унаследует сброшенную маску.
				
		\item fork() и завершается процесс-предок.
		
		Процесс-предок, вызвавший fork, является создателем и лидером группы процессов. Тогда в результате процесс-потомок теряет группу после завершения предка. Он <<усыновляется>> процессом, вызвавшим терминал, для того, чтобы он гарантированно не был лидером группы.
		
		\item setsid() - осиротевший потомок станет демоном (станет лидером группы, но в этой группе он будет один и утратит управляющий терминал). В результате у него будет три одинакового идентификатора [какие?].
		
		\item chdir("/");
		
		UNIX начали разрабатывать с файловой системы. Без нее написать нормальную ОС невозможно. Дело в том, что в UNIX поддерживается огромное количество файловых систем: ext2, ext4, nfs, fat32 и т.д. В основе лежит монтирование файловых систем.
		
		Работать можно только с монтированной файловой системой. Пока работает демон, отмонтировать фаловую систему нельзя.
		
		\item getrlimit(RLIMIT\_NOFILE, \&r1),
		
		где r1 - struct rlimit, в котором есть поле r1.rlim\_max (максимальный номер открытого дескриптора)
		
		r1.rlim\_max = RLIM\_INFINITY (1024) (???)
		
		В UNIX есть просто файл и открытые файлы (для открытых файлов создаются системные таблицы)
		
		В результате вызова этой функции, закрываются все открытые файлы, в том числе файлы, с дескрипторам 0, 1 и 2.
		
		\item fd0 = open("/dev/null"\ O\_RDWR);
		
		fd1 и fd2 - dup;
		
		[что-то про SIGHUP]. Для игнорирования этого сигнала вызываем sigaction с SIG\_IGN
		
		В конце функции demonize инициалищируется файл журнала с помощью функций openlog() и syslog()
	\end{enumerate}

	!!! В отличие от System5, в Linux fork вызывается один раз.
	
	!!! Проработать материал о журналировании ошибок из книги.
	
	Следующая функция, вызывающася в main, - already\_running (13.5)
	
	!!! Своего демона мы запускаем из командной строки.
	
	Файл блокировки (для выполнения демона в единственном экземпляре):
	
	/var/run/<имя> - файл, доступный с правами суперюзера. Создается в пространстве ядра, чтобы не было легко его удалить. Таким образом, получаем гарантию, что демон булет работать в единственном экземпляре.
	
	open(..., LOCKMODE);
	
	lockfile(); (код в книге)
	
	Первый экземпляр демона создасть lockfile. Следующие экземпляры попытаются создать, но получат ошибку.
	
	(13.6)
	
	(13.3)
	
	В демоне (уже в main, который стал потомок) создается дополнительный поток (pthreadcreate) [посмотреть в книге].
	
	(13.4)
	
	Упражнения: 3.1, 3.3
\end{document}
