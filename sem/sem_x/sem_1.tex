\documentclass[14pt, a4paper]{article}

\usepackage{amssymb}
\usepackage{extsizes}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{indentfirst}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[left=30mm, right=10mm, top=20mm, bottom=20mm]{geometry}
\usepackage{ucs}

\graphicspath{{images/}}

\linespread{1.3}
\setcounter{tocdepth}{4}
\setlength{\parskip}{1.5pt}

\begin{document}
	\section{Модели ввода и вывода}
	
	Ввод/вывод - работа с внешними устройствами.

	!!! С ОП мы работаем командой move. Есть в системе локальная шина памяти. Но с внешними устр. мы работаем через порты ввода-вывода (in/out).
	
	Концепция трехшинной архитектуры важна, поскольку разделяются сигналы трех типов.
	
	В 60-70е годы появились интегральные схемы, позволяющие увеличить производительность машины и уменьшить ее габариты. Было осуществлено в IBM360 и IBM370. В этих машинах была реализована концепция распараллеливания функций.
	
	Внешние устройства медленные. Поэтому в состав IBM360 были добавлены специальные процессоры - каналы, которые управляли распараллеливанием функций.
	
	Управление операции ввода/вывода берет на себя канал. При завершении ввода-вывода посылается прерывание процессору (в котроллер прерывания).
	
	В ПК на базе процессоров Intel - шинная архитектура (у IBM - канальная; а у Intel - контроллеры).
	
	Пять моделей ввода-вывода (предназначены для целостного представления об организации ввода-вывода):
	\begin{itemize}
		\item блокирующий ввод-вывод
		
		send\_to и receive\_from (как и read, write, система переходит в режим ядра)
		
		[картинка с блокирующим вводом-выводом]
		
		Когда приложение выполняет запрос вывода-вывода, процесс блокируется, до тех пор не получит необходимые данные. При этом данные готовы в том смысле, что, например, введенный символ записан в буфер клавиатуры. Также, специально выделено копирование (copy complete).
		
		[диаграмма запроса ввода-вывода]
		
		Данная диаграмма демонстрирует последовательность действий системы для обслуживания запросов ввода-вывода. Эта диаграмма есть в книге [какой?].
		
		SVC - Supervisor call (ОС при выполнении называлась Supervisor)
		
		В результате системного вызова система переходит в режим ядра.
		
		IH - interrupt handler.
		
		В этой последовательности вызовов есть функции, составляющие интерфейс ядра, которые вызываются в результате системного вызова. Вызовы этих функций осуществляются последовательно, в зависимости от того, какие флаги установлены, какие данные передаются и т.д. (серьезный структурированный код). В конечном итоге, будет вызвана точка входа драйвера устройства.
		
		Драйвер - многовходовая программа, то есть имеет много точек входа. Один из них - обработчик прерывания. Но когда вызывается драйвер, вызывается его точка входа.
		
		В результате выполнения кода драйвера по шине данных устройству контроллера будет послана команда.
		
		По завершении операции ввода-вывода в буфер клавиатуры записываются данные. Контроллер посылает сигнал прерывания на контроллер прерывания.
		
		В драйвере имеются callback-функции. В результате последовательности вызово данные будут помещены в буфер устройства. То есть весь ввод-вывод, который мы запрашивали, - это блокирующий ввод-вывод. Пока приложение не получит данные, процесс будет заблокирован.
		
		!!! Такой ввод-вывод возможен, если в системе предусмотрены прерывания от внешних устройств.
		
		\item неблокирующий ввод-вывод
		
		Происходит опрос флага готовности контроллера прерывания (то есть происходит обращение к внешнему устройству).
		
		[картинка с неблокирующим вводом-выводом]
		
		Опрос выполняется до тех пор, пока данные не будут готовы. Готовность - поступление в буфер устройства. Данные попадают в буфер ядра, а оттуда - в буфер приложения. Процессорное время тратится на опрос.
		
		Это устаревший способ обращения к внешним устройствам.
		
		\item мультиплексирование ввода-вывода
		
		Мультиплексирование всегда рассматривается для модели клиент-сервера на сокетах.
		
		!!! Мультиплексирование - альтернатива многопоточности.
		
		Для реализации мультиплексирования система предоставляет мультиплексоры - специальные системные вызовы (select и pool).
		
		[диаграмма]
		
		Процесс блокируется на вызове select, ожидая одного возможного взаимодействия с сокетом, который станет готовым (become ready).
		
		Клиенты обращаются к серверу за обслуживанием. Сервер обслуживает запросы клиентов. При этом взаимодействия осуществляются через сокеты (сокет - абстракция точки соединения). Сокеты появились в UNIX BSD, которые позволяли управлять процессами на отдельно стоящих машинах.
		
		Мультиплексирование используется только для распределенных сетей. Мультиплексирование позволяет сократить время блокировки засчет опроса готовности точек соединения. Время ожидания готовности одной любой точки из пула точек соединения будет меньше, чем время ожидания соединения в определенном порядке.
		
		После того, как селектор определил, что соединение установлено, вызывается recvfrom. Когда данные готовы, возвращается readable. Затем, производится копирование.
		
		process datagram - обработка данных.
		
		!!! select вызывается на стороне сервера.
		
		У этой диаграммы есть развернутый вариант
		
		[дополненная диаграмма]
	\end{itemize}
\end{document}
